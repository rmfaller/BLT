
Job:
  descriptions (load gen and target(s))
  number of threads and thread group size (number of threads to spawn at a time) and thread interval (time to wait between thread spawns)
  number of connections and to keep alive for duration or not
  list workload(s) and number of iterations
  following can be overridden by workload and/or task
    endpoint + port
    credentials
    lowerbounds and upperbounds (for user.xxx)

Workloads:
  task(s) + SLA per task
  state to be shared between tasks
  option:
    endpoint + port
    credentials

Tasks:
  API calls
    request type: POST, GET, PATCH, ....
    Headers
    url-endpoint
    url-payload
    data-payload
  option:
    endpoint + port
    credentials

shared values:
  randomvalue
  tokenid
  threadid
  increment

Features to add:
All json stored in DS
ingest cURL commands
tasks can read from files tasks
tasks can be created from existing logs based on usage profile
tasks support LDAP

Code cuts:
//            System.out.println(((JSONObject) wla.get(0)).get("threads"));


21-08-2018:
public void run() {
        int index = 0;
        URL[] url;
        HttpURLConnection[] conn;
        JSONParser jp = new JSONParser();
        JSONArray taska = (JSONArray) workloadconfig.get("task");
        JSONArray workloada = (JSONArray) jobconfig.get("workload");
        JSONObject[] state = new JSONObject[taska.size()];
        JSONArray slp = null;
        for (index = 0; index < taska.size(); index++) {
            slp = getJSONArray(index, "service-location-port");
            url = new URL[slp.size()];
            conn = new HttpURLConnection[slp.size()];
            int instance = 0;
            // from spl, if greater than 1 select the instance
            // may make conn and url not an array
            Long iteration = (Long) ((JSONObject) workloada.get(workloadset)).get("iteration");
            for (int i = 0; i < iteration; i++) {
                if (((String) slp.get(0)).compareTo("$BLT-SLEEP") != 0) {
                    String urlstring = (String) slp.get(instance) + (String) taskconfig[index].get("url-endpoint") + (String) taskconfig[index].get("url-payload");
                    urlstring = replaceVariable(urlstring);
                    urlstring = updateReserved(index, urlstring, state);
                    try {
                        url[instance] = new URI(urlstring).toURL();
                        long taskstart = new Date().getTime();
                        conn[instance] = (HttpURLConnection) url[instance].openConnection();
                        conn[instance].setDoOutput(true);
                        conn[instance].setConnectTimeout(getLong(index, "threshold").intValue());
                        conn[instance].setReadTimeout(getLong(index, "threshold").intValue());
                        conn[instance].setRequestMethod(getString(index, "request"));
//                    System.out.println(((JSONObject) taskconfig[index].get("header")).toString());
                        Iterator<String> iter = ((JSONObject) taskconfig[index].get("header")).keySet().iterator();
                        while (iter.hasNext()) {
                            String headerattr = iter.next();
                            String headervalue = (String) ((JSONObject) taskconfig[index].get("header")).get(headerattr);
                            System.out.println("head= " + headerattr + " attr: " + headervalue);
                            headerattr = replaceVariable(headerattr);
                            headervalue = replaceVariable(headervalue);
                            headerattr = updateReserved(index, headerattr, state);
                            headervalue = updateReserved(index, headervalue, state);
                            System.out.println("post-head= " + headerattr + " attr: " + headervalue + "  t= " + getLong(index, "threshold").intValue() + "wls:" + workloadset + "wlc " + workloadconfig.get("name"));
                            conn[instance].setRequestProperty(headerattr, headervalue);
                        }
                        String dp = null;
                        if (taskconfig[index].containsKey("data-payload")) {
                            dp = ((JSONObject) taskconfig[index].get("data-payload")).toString();
                            dp = replaceVariable(dp);
                            dp = updateReserved(index, dp, state);
                            OutputStreamWriter cwr = new OutputStreamWriter(conn[instance].getOutputStream());
                            cwr.write(dp);
                            cwr.close();
                        }
                        BufferedReader reader = null;
                        reader = new BufferedReader(new InputStreamReader(conn[instance].getInputStream()));
                        String rl = null;
                        StringBuilder sbin = new StringBuilder();
                        while ((rl = reader.readLine()) != null) {
                            sbin.append(rl);
                        }
                        System.out.println("iteration= "+ iteration + "  sbin= " + sbin);
                        reader.close();
                        conn[instance].disconnect();
                        long taskstop = new Date().getTime();
//                        result.put(this.threadid + ((JSONObject) taska.get(i)).get("name").toString() + "-lapsedtime", (taskstop - taskstart) + result.get(this.threadid + ((JSONObject) taska.get(i)).get("name").toString() + "-lapsedtime"));
                        result.addTo(this.threadid + ((JSONObject) taska.get(index)).get("name").toString() + "-lapsedtime", (taskstop - taskstart));
                        result.addTo(this.threadid + ((JSONObject) taska.get(index)).get("name").toString() + "-passed", 1);
                        state[index] = (JSONObject) jp.parse(sbin.toString());
                    } catch (URISyntaxException | ParseException | IOException ex) {
                        Logger.getLogger(Worker.class.getName()).log(Level.SEVERE, null, ex);
                    }
                } else {
                    try {
                        Thread.sleep((Long) taskconfig[index].get("sleep-time"));
                    } catch (InterruptedException ex) {
                        Logger.getLogger(Worker.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }
        }
        StringBuffer sb = new StringBuffer(threadid + " : " + jobconfig + "\n\t Taskset " + workloadset + ": " + workloadconfig + "\n");
        for (int i = 0; i < taskconfig.length; i++) {
            sb.append("\t\ttask ").append(i).append(": ").append(taskconfig[i]).append("\n");
        }
        String s = sb + "\n====================================\n";
        result.config = s;
    }

    private String getString(int index, String key) {
        String value = null;
        JSONArray ja;
        if (taskconfig[index].containsKey(key)) {
            value = (String) taskconfig[index].get(key);
        } else {
            ja = (JSONArray) workloadconfig.get("task");
            if (((JSONObject) ja.get(index)).containsKey(key)) {
                value = (String) (((JSONObject) ja.get(index)).get(key));
            } else {
                if (workloadconfig.containsKey(key)) {
                    value = (String) workloadconfig.get(key);
                } else {
                    ja = (JSONArray) jobconfig.get("workload");
                    for (int i = 0; i < ja.size(); i++) {
                        if (((JSONObject) ja.get(i)).get("name").equals(workloadconfig.get("name"))) {
                            value = (String) (((JSONObject) ja.get(i)).get(key));
                        }
                    }
                    if (value == null) {
                        value = (String) jobconfig.get(key);
                    }
                }
            }
        }
        return value;
    }

    private Long getLong(int index, String key) {
        Long value = null;
        JSONArray ja;
        if (taskconfig[index].containsKey(key)) {
            value = (Long) taskconfig[index].get(key);
        } else {
            ja = (JSONArray) workloadconfig.get("task");
            if (((JSONObject) ja.get(index)).containsKey(key)) {
                value = (Long) (((JSONObject) ja.get(index)).get(key));
            } else {
                if (workloadconfig.containsKey(key)) {
                    value = (Long) workloadconfig.get(key);
                } else {
                    ja = (JSONArray) jobconfig.get("workload");
                    for (int i = 0; i < ja.size(); i++) {
                        if (((JSONObject) ja.get(i)).get("name").equals(workloadconfig.get("name"))) {
                            value = (Long) (((JSONObject) ja.get(i)).get(key));
                        }
                    }
                    if (value == null) {
                        value = (Long) jobconfig.get(key);
                    }
                }
            }
        }
        return value;
    }

    private JSONArray getJSONArray(int index, String key) {
        JSONArray ja;
        if (taskconfig[index].containsKey(key)) {
            ja = (JSONArray) taskconfig[index].get(key);
        } else {
            if (workloadconfig.containsKey(key)) {
                ja = (JSONArray) workloadconfig.get(key);
            } else {
                ja = (JSONArray) jobconfig.get(key);
            }
        }
        return ja;
    }

    private String replaceVariable(String tmpstring) {
        String ks = null;
        String kv = null;
        for (Object key : bltenv.keySet()) {
            ks = (String) key;
            if (bltenv.get(key).getClass() == Long.class) {
                kv = ((Long) bltenv.get(ks)).toString();
            } else {
                if (bltenv.get(key).getClass() == String.class) {
                    kv = (String) bltenv.get(ks);
                } else {
                    kv = ((Boolean) bltenv.get(ks)).toString();
                }
            }
            tmpstring = tmpstring.replace(ks, kv);
        }
        return tmpstring;
    }

    private String updateReserved(int index, String tmpstring, JSONObject[] state) {
        String ks = null;
        String kv = null;
        for (Object key : reserved.keySet()) {
            ks = (String) key;
            switch (ks) {
                case "$BLT-RANDOM-NUMBER":
                    Long randomvalue = (long) (Math.random() * ((long) getLong(index, "value-top") + 1));
                    tmpstring = tmpstring.replace(ks, randomvalue.toString());
                    break;
                case "$BLT-TOKEN-PAYLOAD":
                    kv = (String) reserved.get(ks);
                    boolean found = false;
                    int i = state.length - 1;
                    while ((!found) && (i >= 0)) {
                        System.out.println("tmp=" + i + "::" + tmpstring + "==" + state[i]);
                        if (state[i] != null) {
                            System.out.println("state " + state[i] + " i " + i + "kv:" + kv);
                            if (state[i].containsKey(kv)) {
                                tmpstring = tmpstring.replace(ks, (String) state[i].get(kv));
                                found = true;
                            }
                        }
                        i--;
                    }
                default:
                    break;
            }
        }
        System.out.println("tmp= " + tmpstring);
        return tmpstring;
    }

}
